/**
 * Timeline Aggregator for Court Order Interpreter
 *
 * This module processes timeline arrays generated by the LLM to calculate
 * care statistics (nights, percentages) for each parent.
 *
 * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 8.1, 8.2, 8.3
 */

import {
    CareCalculationResult,
    ParentCode,
    TimelineBlock,
    TimelineResponse,
    TypeCode,
    getTotalDaysInYear,
} from './timeline-types';

/**
 * Parse an ISO datetime string with minute precision to a Date object.
 * Expected format: "YYYY-MM-DDTHH:mm"
 */
export function parseISOMinute(isoString: string): Date {
  // Handle format "YYYY-MM-DDTHH:mm"
  const [datePart, timePart] = isoString.split('T');
  const [year, month, day] = datePart.split('-').map(Number);
  const [hours, minutes] = timePart.split(':').map(Number);
  return new Date(year, month - 1, day, hours, minutes);
}

/**
 * Calculate duration in minutes between two dates.
 */
export function calculateDurationMinutes(start: Date, end: Date): number {
  return Math.floor((end.getTime() - start.getTime()) / (1000 * 60));
}

/**
 * Calculate total minutes for each parent from timeline blocks.
 * Requirements: 4.1
 *
 * @param timeline - Array of timeline blocks
 * @returns Object with motherMinutes and fatherMinutes
 */
export function calculateMinutesPerParent(timeline: TimelineBlock[]): {
  motherMinutes: number;
  fatherMinutes: number;
} {
  let motherMinutes = 0;
  let fatherMinutes = 0;

  for (const block of timeline) {
    const [startStr, endStr, parent] = block;
    const start = parseISOMinute(startStr);
    const end = parseISOMinute(endStr);
    const duration = calculateDurationMinutes(start, end);

    if (parent === 'M') {
      motherMinutes += duration;
    } else {
      fatherMinutes += duration;
    }
  }

  return { motherMinutes, fatherMinutes };
}


/**
 * Determine which parent has care at a specific datetime.
 * Used for midnight rule night counting.
 *
 * @param timeline - Array of timeline blocks
 * @param datetime - The datetime to check
 * @returns The parent code ('M' or 'F') who has care at that time, or null if not found
 */
export function getParentAtTime(timeline: TimelineBlock[], datetime: Date): ParentCode | null {
  const targetTime = datetime.getTime();

  for (const block of timeline) {
    const [startStr, endStr, parent] = block;
    const start = parseISOMinute(startStr);
    const end = parseISOMinute(endStr);

    // Check if datetime falls within this block [start, end)
    // Note: end time is exclusive for the current block
    if (targetTime >= start.getTime() && targetTime < end.getTime()) {
      return parent;
    }
  }

  // Check if datetime equals the end of the last block (edge case for year end)
  if (timeline.length > 0) {
    const lastBlock = timeline[timeline.length - 1];
    const lastEnd = parseISOMinute(lastBlock[1]);
    if (targetTime === lastEnd.getTime()) {
      return lastBlock[2];
    }
  }

  return null;
}

/**
 * Count nights per parent using the midnight rule.
 * A night is attributed to the parent who has care at 23:59 of that day.
 * Requirements: 4.2
 *
 * @param timeline - Array of timeline blocks
 * @param year - The year to count nights for (used as starting point)
 * @returns Object with motherNights and fatherNights
 */
export function countNightsPerParent(
  timeline: TimelineBlock[],
  year: number
): {
  motherNights: number;
  fatherNights: number;
} {
  let motherNights = 0;
  let fatherNights = 0;

  if (timeline.length === 0) {
    return { motherNights: 0, fatherNights: 0 };
  }

  // Calculate actual timeline duration from first to last block
  const firstBlock = timeline[0];
  const lastBlock = timeline[timeline.length - 1];
  const startDate = parseISOMinute(firstBlock[0]);
  const endDate = parseISOMinute(lastBlock[1]);
  
  // Calculate number of days in the timeline
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));

  // Iterate through each day of the timeline
  for (let dayIndex = 0; dayIndex < totalDays; dayIndex++) {
    // Create datetime for 23:59 of this day
    const date = new Date(startDate);
    date.setDate(date.getDate() + dayIndex);
    date.setHours(23, 59, 0, 0);
    
    const parent = getParentAtTime(timeline, date);

    if (parent === 'M') {
      motherNights++;
    } else if (parent === 'F') {
      fatherNights++;
    }
  }

  return { motherNights, fatherNights };
}


/**
 * Calculate care percentages from night counts.
 * Requirements: 4.3
 *
 * @param motherNights - Number of nights for mother
 * @param fatherNights - Number of nights for father
 * @returns Object with motherPercentage and fatherPercentage (0-100)
 */
export function calculatePercentages(
  motherNights: number,
  fatherNights: number
): {
  motherPercentage: number;
  fatherPercentage: number;
} {
  const totalNights = motherNights + fatherNights;

  if (totalNights === 0) {
    return { motherPercentage: 0, fatherPercentage: 0 };
  }

  const motherPercentage = (motherNights / totalNights) * 100;
  const fatherPercentage = (fatherNights / totalNights) * 100;

  return {
    motherPercentage: Math.round(motherPercentage * 100) / 100,
    fatherPercentage: Math.round(fatherPercentage * 100) / 100,
  };
}

/**
 * Calculate care statistics from a timeline response.
 * This is the main aggregation function that processes the LLM-generated timeline.
 *
 * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5
 *
 * @param response - The timeline response from the LLM
 * @returns Complete care calculation result
 */
export function calculateCareFromTimeline(response: TimelineResponse): CareCalculationResult {
  const { timeline, year } = response;
  
  // Calculate actual timeline duration
  let totalDays = getTotalDaysInYear(year);
  if (timeline.length > 0) {
    const firstBlock = timeline[0];
    const lastBlock = timeline[timeline.length - 1];
    const startDate = parseISOMinute(firstBlock[0]);
    const endDate = parseISOMinute(lastBlock[1]);
    totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
  }

  // Count nights using midnight rule (Requirements: 4.2)
  const { motherNights, fatherNights } = countNightsPerParent(timeline, year);

  // Calculate percentages (Requirements: 4.3)
  const { motherPercentage, fatherPercentage } = calculatePercentages(motherNights, fatherNights);

  // Return complete result (Requirements: 4.4, 4.5)
  return {
    totalDays,
    motherNights,
    fatherNights,
    motherPercentage,
    fatherPercentage,
    motherNightsPerYear: motherNights,
    fatherNightsPerYear: fatherNights,
    timeline,
  };
}

/**
 * Format a timeline array to a human-readable string.
 * Each block is formatted as: "START|END|PARENT|TYPE"
 * Blocks are separated by newlines.
 *
 * Requirements: 8.1, 8.2
 *
 * @param timeline - Array of timeline blocks
 * @returns Human-readable string representation
 */
export function formatTimeline(timeline: TimelineBlock[]): string {
  return timeline
    .map((block) => {
      const [start, end, parent, type] = block;
      return `${start}|${end}|${parent}|${type}`;
    })
    .join('\n');
}

/**
 * Parse a formatted timeline string back to a timeline array.
 * This is the inverse of formatTimeline for round-trip testing.
 *
 * Requirements: 8.3
 *
 * @param str - Formatted timeline string (from formatTimeline)
 * @returns Array of timeline blocks
 * @throws Error if the string format is invalid
 */
export function parseTimelineString(str: string): TimelineBlock[] {
  if (str.trim() === '') {
    return [];
  }

  const lines = str.split('\n');
  return lines.map((line, index) => {
    const parts = line.split('|');
    if (parts.length !== 4) {
      throw new Error(`Invalid timeline line format at line ${index + 1}: expected 4 parts, got ${parts.length}`);
    }

    const [start, end, parent, type] = parts;

    // Validate parent code
    if (parent !== 'M' && parent !== 'F') {
      throw new Error(`Invalid parent code at line ${index + 1}: expected 'M' or 'F', got '${parent}'`);
    }

    // Validate type code
    if (type !== 'base' && type !== 'holiday' && type !== 'christmas') {
      throw new Error(`Invalid type code at line ${index + 1}: expected 'base', 'holiday', or 'christmas', got '${type}'`);
    }

    return [start, end, parent as ParentCode, type as TypeCode] as TimelineBlock;
  });
}
